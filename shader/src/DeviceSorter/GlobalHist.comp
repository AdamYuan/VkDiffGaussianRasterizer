#version 460
#extension GL_EXT_control_flow_attributes : require
#include "Common.glsl"

layout(local_size_x = GLOBAL_HIST_DIM, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = SBUF_SRC_KEYS_BINDING) readonly buffer bSrcKeys { SortKey gSrcKeys[]; };
layout(std430, binding = SBUF_GLOBAL_HISTS_BINDING) buffer bGlobalHists {
	uint gGlobalHists[]; // Size: RADIX * PASS_COUNT
};

#define SHARED_HIST_SIZE (PASS_COUNT * RADIX)
#define SHARED_PASS_HIST(PASS_IDX, DIGIT) gShared[(PASS_IDX) * RADIX + (DIGIT)]

shared uint gShared[SHARED_HIST_SIZE]; // Shared memory for GlobalHistogram

void main() {
	uint groupThreadIdx = gl_LocalInvocationID.x, groupIdx = gl_WorkGroupID.x, groupCount = gl_NumWorkGroups.x;

	SortKey keys[GLOBAL_HIST_KEYS_PER_THREAD];

	uint firstLoadIdx = groupIdx * GLOBAL_HIST_PART_SIZE + groupThreadIdx;

	[[branch]] if (groupIdx < groupCount - 1) {
		[[unroll]] for (uint i = 0, t = firstLoadIdx; i < GLOBAL_HIST_KEYS_PER_THREAD; ++i, t += GLOBAL_HIST_DIM)
			keys[i] = gSrcKeys[t];
	} else {
		[[unroll]] for (uint i = 0, t = firstLoadIdx; i < GLOBAL_HIST_KEYS_PER_THREAD; ++i, t += GLOBAL_HIST_DIM)
			keys[i] = t < gKeyCount ? gSrcKeys[t] : 0xFFFFFFFF;
	}

	// Clear shared memory
	for (uint i = groupThreadIdx; i < SHARED_HIST_SIZE; i += GLOBAL_HIST_DIM)
		gShared[i] = 0;

	barrier();
	groupMemoryBarrier();

	[[unroll]] for (uint keyIdx = 0; keyIdx < GLOBAL_HIST_KEYS_PER_THREAD; ++keyIdx) {
		uint key = keys[keyIdx];
		[[unroll]] for (uint passIdx = 0; passIdx < PASS_COUNT; ++passIdx) {
			uint radix = extractKeyRadix(key, passIdx * BITS_PER_PASS);
			atomicAdd(SHARED_PASS_HIST(passIdx, radix), 1);
		}
	}

	barrier();
	groupMemoryBarrier();

	if (groupThreadIdx < RADIX - 1) {
		// ` < RADIX - 1` since the last radix is useless after exculsive prefix-sum
		[[unroll]] for (uint passIdx = 0; passIdx < PASS_COUNT; ++passIdx) {
			uint passHist = SHARED_PASS_HIST(passIdx, groupThreadIdx);

			if (passHist > 0)
				atomicAdd(gGlobalHists[RADIX * passIdx + groupThreadIdx], passHist);
		}
	}
}
