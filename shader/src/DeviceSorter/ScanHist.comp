#version 460
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#include "Common.glsl"
#include "Wave.glsl"

layout(local_size_x = RADIX, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = B_GLOBAL_HISTS_BINDING) readonly buffer bGlobalHists {
	uint gGlobalHists[]; // Size: RADIX * PASS_COUNT
};
layout(std430, binding = B_PASS_HISTS_BINDING) writeonly buffer bPassHists {
	uint gPassHists[]; // Size: divCeil(gKeyCount, SORT_PART_SIZE) * RADIX * PASS_COUNT
};

shared uint gShared[RADIX / LANES_PER_WAVE];

// Exclusive prefix sum for Histograms

void main() {
	uint waveLaneIdx = gl_SubgroupInvocationID,                       //
	    groupWaveIdx = gl_SubgroupID,                                 // gl_LocalInvocationID.x / LANES_PER_WAVE
	    groupThreadIdx = groupWaveIdx * LANES_PER_WAVE + waveLaneIdx, //
	    groupIdx = gl_WorkGroupID.x;

	// groupIdx is passIdx

	uint hist = gGlobalHists[groupIdx * RADIX + groupThreadIdx];
	uint wavePrefixSum = subgroupExclusiveAdd(hist);

	if (waveLaneIdx == LANES_PER_WAVE - 1)
		gShared[groupWaveIdx] = wavePrefixSum + hist;

	barrier();
	groupMemoryBarrier();

#if RADIX / LANES_PER_WAVE > LANES_PER_WAVE
#error LANES_PER_WAVE too small
#endif
	if (groupThreadIdx < (RADIX / LANES_PER_WAVE))
		gShared[groupThreadIdx] = subgroupExclusiveAdd(gShared[groupThreadIdx]);

	barrier();
	groupMemoryBarrier();

	uint prefixSum = wavePrefixSum + gShared[groupWaveIdx];
	gPassHists[groupIdx * RADIX * getSortPartCount() + groupThreadIdx] = (prefixSum << 2) | FLAG_INCLUSIVE;
	// Initial prefix for decoupled look-back prefix scan
}
