#version 460
#extension GL_EXT_control_flow_attributes : require
#include "Common.glsl"

layout(local_size_x = GLOBAL_HIST_DIM, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = B_SRC_KEYS_BINDING) readonly buffer bSrcKeys { SortKey gSrcKeys[]; };
layout(std430, binding = B_GLOBAL_HISTS_BINDING) buffer bGlobalHists {
	uint gGlobalHists[]; // Size: RADIX * PASS_COUNT
};

#define HISTS_PER_GROUP 2

#define SHARED_HIST_SIZE (HISTS_PER_GROUP * PASS_COUNT * RADIX)
#define SHARED_PASS_HIST(PASS_IDX, HIST_IDX, DIGIT) \
	gShared[((PASS_IDX) * HISTS_PER_GROUP + (HIST_IDX)) * RADIX + (DIGIT)]

shared uint gShared[SHARED_HIST_SIZE]; // Shared memory for GlobalHistogram

void main() {
	uint groupThreadIdx = gl_LocalInvocationID.x, groupIdx = gl_WorkGroupID.x, groupCount = gl_NumWorkGroups.x;

	// Clear shared memory
	for (uint i = groupThreadIdx; i < SHARED_HIST_SIZE; i += GLOBAL_HIST_DIM)
		gShared[i] = 0;

	barrier();
	groupMemoryBarrier();

	// Counting
	for (uint i = groupIdx * GLOBAL_HIST_PART_SIZE + groupThreadIdx,
	          histID = groupThreadIdx / (GLOBAL_HIST_DIM / HISTS_PER_GROUP),
	          end = groupIdx == groupCount - 1 ? gKeyCount : (groupIdx + 1) * GLOBAL_HIST_PART_SIZE;
	     i < end; i += GLOBAL_HIST_DIM) {
		SortKey key = gSrcKeys[i];

		[[unroll]] for (uint passID = 0; passID < PASS_COUNT; ++passID) {
			uint radix = extractKeyRadix(key, passID * BITS_PER_PASS);
			atomicAdd(SHARED_PASS_HIST(passID, histID, radix), 1);
		}
	}

	barrier();
	groupMemoryBarrier();

	// Reduce and write
	for (uint i = groupThreadIdx; i < RADIX; i += GLOBAL_HIST_DIM) {
		[[unroll]] for (uint passID = 0; passID < PASS_COUNT; ++passID) {
			uint sum = SHARED_PASS_HIST(passID, 0, i);
			[[unroll]] for (uint histID = 1; histID < HISTS_PER_GROUP; ++histID)
				sum += SHARED_PASS_HIST(passID, histID, i);

			atomicAdd(gGlobalHists[RADIX * passID + i], sum);
		}
	}
}
